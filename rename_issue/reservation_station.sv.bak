module reservation_station #(
    parameter RS_SIZE = 8,
    parameter PR_BITS = 6
)(
    input  logic clk,
    input  logic rst,

    // Dispatch (from rename)
    input  logic dispatch_en,
    input  logic [PR_BITS-1:0] src1,
    input  logic [PR_BITS-1:0] src2,
    input  logic [PR_BITS-1:0] dst,
    input  logic src1_ready,
    input  logic src2_ready,
    input  logic use_imm,
    input  logic [31:0] imm,

    // Wakeup
    input  logic wb_valid,
    input  logic [PR_BITS-1:0] wb_phys,

    // Issue handshake
    input  logic issue_grant,

    // Issue outputs
    output logic issue_valid,
    output logic [PR_BITS-1:0] issue_src1,
    output logic [PR_BITS-1:0] issue_src2,
    output logic [PR_BITS-1:0] issue_dst,
    output logic issue_use_imm,
    output logic [31:0] issue_imm,
    output logic [$clog2(RS_SIZE)-1:0] issue_idx
);

    typedef struct packed {
        logic valid;
        logic rdy1;
        logic rdy2;
        logic [PR_BITS-1:0] s1;
        logic [PR_BITS-1:0] s2;
        logic [PR_BITS-1:0] d;
        logic use_imm;
        logic [31:0] imm;
    } rs_entry_t;

    rs_entry_t rs[RS_SIZE];

    /* =====================================================
       SEQUENTIAL
       ===================================================== */
    always_ff @(posedge clk or posedge rst) begin
        if (rst) begin
            for (int i = 0; i < RS_SIZE; i++) begin
                rs[i].valid <= 1'b0;
                rs[i].rdy1  <= 1'b0;
                rs[i].rdy2  <= 1'b0;
                rs[i].s1    <= '0;
                rs[i].s2    <= '0;
                rs[i].d     <= '0;
                rs[i].use_imm <= 1'b0;
                rs[i].imm   <= '0;
            end
        end else begin

            // -------------------------
            // Wakeup
            // -------------------------
            if (wb_valid) begin
                for (int i = 0; i < RS_SIZE; i++) begin
                    if (rs[i].valid) begin
                        if (rs[i].s1 == wb_phys) rs[i].rdy1 <= 1'b1;
                        if (rs[i].s2 == wb_phys) rs[i].rdy2 <= 1'b1;
                    end
                end
            end

            // -------------------------
            // Dispatch (ONLY if dst is VALID)
            // -------------------------
            if (dispatch_en && dst !== 'x && dst != 0) begin
                for (int i = 0; i < RS_SIZE; i++) begin
                    if (!rs[i].valid) begin
                        rs[i].valid   <= 1'b1;
                        rs[i].rdy1    <= src1_ready;
                        rs[i].rdy2    <= src2_ready;
                        rs[i].s1      <= src1;
                        rs[i].s2      <= src2;
                        rs[i].d       <= dst;
                        rs[i].use_imm <= use_imm;
                        rs[i].imm     <= imm;
                        break;
                    end
                end
            end

            // -------------------------
            // Clear ONLY issued entry
            // -------------------------
            if (issue_valid && issue_grant) begin
                rs[issue_idx].valid <= 1'b0;
            end
        end
    end

    /* =====================================================
       COMBINATIONAL ISSUE SELECT
       ===================================================== */
    always_comb begin
        issue_valid   = 1'b0;
        issue_src1    = '0;
        issue_src2    = '0;
        issue_dst     = '0;
        issue_use_imm = 1'b0;
        issue_imm     = '0;
        issue_idx     = '0;

        for (int i = 0; i < RS_SIZE; i++) begin
            if (rs[i].valid && rs[i].rdy1 && rs[i].rdy2) begin
                issue_valid   = 1'b1;
                issue_src1    = rs[i].s1;
                issue_src2    = rs[i].s2;
                issue_dst     = rs[i].d;
                issue_use_imm = rs[i].use_imm;
                issue_imm     = rs[i].imm;
                issue_idx     = i;
                break;
            end
        end
    end

endmodule
